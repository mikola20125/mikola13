Ответ на первые задания.
На примере сайта-магазина.
Был создан класс Product в каталоге товаров(magazine/catalog/class_Product.php), внутри которого были объявлены все основные св-ва продукта(id, name, price, img,description,shortDescription),значения которых берутся из таблицы БД и присваиваются свой-вам в методе makeProduct и затем в классе создается метод, отвечающий за вывод  объекта "продукт" showProduct. Этот класс был создан в папке каталог с целью вывода всех существующих продуктов в БД.  Реализация вывода находится в файле magazine/catalog/engine.php.

В файле magazine/products/class_FullProduct.php был создан наследник класса Product  - FullProduct для реализации вывода подробных свойств и характеристик товара, а также для минимизации дублирования кода. Этот класс унаследовал все св-ва и методы родителя, но был дополнен методом showFullProduct, кот реализовывает вывод одробных характеристик товара. Реализация вывода в файле magazine/products/engine.php



5. Дан код:
class A {
    public function foo() {
        static $x = 0;
        echo ++$x;
    }
}
$a1 = new A();
$a2 = new A();
$a1->foo();
$a2->foo();
$a1->foo();
$a2->foo();
Что он выведет на каждом шаге? Почему?

                                                                          Ответ(https://habr.com/post/259627/).
Выведет: 1234;
В PHP переменные локальны. Это значит, что переменная, определенная и получившая значение внутри функции (метода), существует только во время выполнения этой функции (метода). При выходе из метода локальная переменная уничтожается, а при повторном входе — создается заново. В коде выше такой локальной переменной является переменная $x — она существует только внутри функции foo() и каждый раз при вызове этой функции создается заново. Сколько бы раз мы не вызвали функцию foo(), она всегда будет выводить 1…;
Однако всё меняется, если мы перед присваиванием поставим ключевое слово static:
Ключевое слово static, написанное перед присваиванием значения локальной переменной, приводит к следующим эффектам:
1.Присваивание выполняется только один раз, при первом вызове функции
2.Значение помеченной таким образом переменной сохраняется после окончания работы функции
3.При последующих вызовах функции вместо присваивания переменная получает сохраненное ранее значение
Такое использование слова static называется статическая локальная переменная.
И так как оба объекта принадлежат одному классу, а методы существуют в единственном экземпляре(динамические методы в PHP «не размножаются»), то при вызове общего метода переменная $x будет увеличиваться на 1.


Немного изменим п.5:
class A {
    public function foo() {
        static $x = 0;
        echo ++$x;
    }
}
class B extends A {
}
$a1 = new A();
$b1 = new B();
$a1->foo(); 
$b1->foo(); 
$a1->foo(); 
$b1->foo();
6. Объясните результаты в этом случае.
				Ответ(https://habr.com/post/259627/).
Выведет: 1122;
Наследование класса (и метода) приводит к тому, что всё-таки создается новый метод.

7. *Дан код:
class A {
    public function foo() {
        static $x = 0;
        echo ++$x;
    }
}
class B extends A {
}
$a1 = new A;
$b1 = new B;
$a1->foo(); 
$b1->foo(); 
$a1->foo(); 
$b1->foo(); 
Что он выведет на каждом шаге? Почему?

				Ответ(https://habr.com/post/259627/).
Выведет: 1122;
Наследование класса (и метода) приводит к тому, что всё-таки создается новый метод.
Отличие от задания №5 в том, что при создании объекта класса не проставляются круглые скобки после его названия, т.к. они необязательны(внутри класса нет конструктора, которому можно было бы передавать параметры).

